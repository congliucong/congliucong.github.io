<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这篇文章打算对Thread类进行一个全方位的总结，包括但不限于Thread类的一些方法，线程提交、线程池等等，只能跟线程相关的都可以，这是个不断的过程。。。 ヾ(◍°∇°◍)ﾉﾞ">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础之Thread">
<meta property="og:url" content="http://yoursite.com/2020/07/06/java-thread/index.html">
<meta property="og:site_name" content="Lcccc">
<meta property="og:description" content="这篇文章打算对Thread类进行一个全方位的总结，包括但不限于Thread类的一些方法，线程提交、线程池等等，只能跟线程相关的都可以，这是个不断的过程。。。 ヾ(◍°∇°◍)ﾉﾞ">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/v2-326a2be9b86b1446d75b6f52f54c98fb_720w.jpg">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/image-20210116004451042.png">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/image-20210116010041638.png">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/0102CBE4.png">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/image-20210116015403271.png">
<meta property="og:image" content="http://yoursite.com/2020/07/06/java-thread/image-20210116142811213.png">
<meta property="article:published_time" content="2020-07-06T14:11:54.000Z">
<meta property="article:modified_time" content="2021-01-18T05:23:52.338Z">
<meta property="article:author" content="Lcc">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/06/java-thread/v2-326a2be9b86b1446d75b6f52f54c98fb_720w.jpg">

<link rel="canonical" href="http://yoursite.com/2020/07/06/java-thread/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java基础之Thread | Lcccc</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lcccc</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-java基础">

    <a href="/categories/Java%E5%9F%BA%E7%A1%80" rel="section"><i class="fab fa-java fa-fw"></i>Java基础</a>

  </li>
        <li class="menu-item menu-item-jvm相关">

    <a href="/categories/Jvm%E7%9B%B8%E5%85%B3" rel="section"><i class="fab fa-java fa-fw"></i>Jvm相关</a>

  </li>
        <li class="menu-item menu-item-redis">

    <a href="/categories/Redis" rel="section"><i class="far fa-registered fa-fw"></i>Redis</a>

  </li>
        <li class="menu-item menu-item-消息中间件">

    <a href="/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6" rel="section"><i class="far fa-meh-blank fa-fw"></i>消息中间件</a>

  </li>
        <li class="menu-item menu-item-dubbo">

    <a href="/categories/Dubbo" rel="section"><i class="fas fa-landmark fa-fw"></i>Dubbo</a>

  </li>
        <li class="menu-item menu-item-spring">

    <a href="/categories/Spring" rel="section"><i class="fas fa-landmark fa-fw"></i>Spring</a>

  </li>
        <li class="menu-item menu-item-mysql">

    <a href="/categories/Mysql" rel="section"><i class="fas fa-database fa-fw"></i>Mysql</a>

  </li>
        <li class="menu-item menu-item-分布式相关">

    <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F" rel="section"><i class="fas fa-network-wired fa-fw"></i>分布式相关</a>

  </li>
        <li class="menu-item menu-item-算法">

    <a href="/categories/%E7%AE%97%E6%B3%95" rel="section"><i class="fas fa-child fa-fw"></i>算法</a>

  </li>
        <li class="menu-item menu-item-杂谈">

    <a href="/categories/%E6%9D%82%E8%B0%88" rel="section"><i class="far fa-smile-wink fa-fw"></i>杂谈</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fas fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/06/java-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lcc">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lcccc">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础之Thread
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-06 22:11:54" itemprop="dateCreated datePublished" datetime="2020-07-06T22:11:54+08:00">2020-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/06/java-thread/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/06/java-thread/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章打算对Thread类进行一个全方位的总结，包括但不限于Thread类的一些方法，线程提交、线程池等等，只能跟线程相关的都可以，这是个不断的过程。。。</p>
<p>ヾ(◍°∇°◍)ﾉﾞ</p>
<a id="more"></a>

<h3 id="Thread生命周期"><a href="#Thread生命周期" class="headerlink" title="Thread生命周期"></a>Thread生命周期</h3><p>其实从第一个问题，已经产生分歧了，因为在网上很多文章总结线程的状态有5种，分别是：新建(NEW)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)。但是真的是这样么？打开JDK的源码，发现在Thread类里面，存在一个<strong>State</strong>枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A thread can be in only one state at a given point in time.</span></span><br><span class="line"><span class="comment">     * These states are virtual machine states which do not reflect</span></span><br><span class="line"><span class="comment">     * any operating system thread states.	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个枚举的注释中， <strong>A thread can be in only one state at a given point in time.These states are virtual machine states which do not reflect any operating system thread states.</strong>    意思是：一个线程在一个时刻只能有一种状态，而这种状态是JVM虚拟机的状态，它和操作系统状态没有任何关系。因此，可以感觉最上面提到的五种状态有可能是没有分清这点。</p>
<p>因此，从源码出发，线程的状态分别是：</p>
<ol>
<li><strong>NEW</strong>。<strong>初始状态</strong>，线程刚被创建，但是还没有调用start方法。</li>
<li><strong>RUNNABLE</strong>。<strong>运行状态</strong>，从注释中可以看出：处于Runnable状态下的线程正在JVM中运行，但可能正在等待来自操作系统其它资源。因此，Java线程是将操作系统中的就绪（Ready）和运行中（Running）两种状态都笼统成为”运行“。</li>
<li><strong>BLOCKED</strong>。<strong>阻塞状态</strong>，表明线程在等待锁，被阻塞。</li>
<li><strong>WAITTING</strong>。<strong>等待状态</strong>，线程处于等待状态，会被例如 Object.wait、Thread.join、LockSupport.park所唤醒。</li>
<li><strong>TIME_WAITTING</strong>。<strong>超时等待状态</strong>，不同于等待状态的是，它可以在指定时间后自动唤醒，即有可能是持有锁的情况下等待。</li>
<li><strong>TERMINATED</strong>。<strong>中止状态</strong>，表示线程已经执行完毕。</li>
</ol>
<p><img src="/2020/07/06/java-thread/v2-326a2be9b86b1446d75b6f52f54c98fb_720w.jpg" alt></p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a><strong>Runnable</strong>接口</h4><p>首先，Thread类实现了<strong>Runnable</strong>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong>Runnable接口</strong>则只有一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释的意思是：如果实现了Runnable接口去创建一个线程，当启动线程后，会执行对象的run方法。</p>
<p>而且这个接口还被<strong>@FunctionalInterface</strong>注解标注，意思是这是一个函数式接口，可以用Lambda表达式来创建Runnable接口的实例。</p>
<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><p><img src="/2020/07/06/java-thread/image-20210116004451042.png" alt></p>
<p>从注释中可以清晰的看到，创建线程只有两种方法：</p>
<ol>
<li><p>实现一个类<strong>继承Thread类</strong>，随后调用其start方法。</p>
</li>
<li><p>实现一个类<strong>实现Runnable接口</strong>，实现其run方法，然后通过Thread类的构造函数new一个Thread类，最后调用其start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>但是，调用start方法是怎么最终会执行run方法呢？</p>
<p>这是因为在start方法里面有一个start0()的本地方法。在这个本地方法里面最终会调用run方法。具体可以参考<a href="https://zhuanlan.zhihu.com/p/95785186" target="_blank" rel="noopener">这里</a></p>
<p><img src="/2020/07/06/java-thread/image-20210116010041638.png" alt></p>
<p>​    3. 第三种方式是<strong>Callable和Future创建线程</strong>。通过实现Callable接口，重写其call方法，然后使用FutureTask类来包装它，因为FutureTask类实现了RunnableFuture接口，而RunnbaleFuture接口又继承了Runnable和Future接口，因此可以使得FutureTask作为Thread构造方法来创建线程。这个我们下篇再进行分析。</p>
<h4 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h4><h5 id="currentThread方法"><a href="#currentThread方法" class="headerlink" title="currentThread方法"></a>currentThread方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这是一个静态的本地方法，返回的是当前正在执行这段代码的线程。</p>
<h5 id="sleep-long-方法"><a href="#sleep-long-方法" class="headerlink" title="sleep(long)方法"></a>sleep(long)方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment"> * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment"> * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment"> * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，sleep也是一个静态的本地方法，而且在注释里面有一句很重要的话是：<strong>The thread does not lose ownership of any monitors.</strong> 意思是：虽然sleep方法使得当前线程让出了cpu，但是并没有释放线程所获得monitor锁。</p>
<p>这里有个常见的问题是：<strong>sleep方法跟wait方法有什么区别？</strong></p>
<p>首先，这两个方式属于不同的类，sleep方法属于Thread类，而wait方法属于Object类。</p>
<p>其次，作用原理也不同。Thread.sleep()是让线程休眠一段时间，但是并没有失去获得的监视器锁，一段时间后轮到时间片后会继续执行；而Object.wait方法则是让阻塞当前线程，并且让出监视器锁，不在参与竞争，需要等待其他线程通知。</p>
<p>还有就是，使用方式上面，sleep直接可以通过Thread.sleep() 或者 Thread.currentThread().sleep()使用，而wait方法则必须配合synchronized使用。</p>
<p>具体线程通信我们后面再说。</p>
<h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment"> * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment"> * hint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment"> * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment"> * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment"> * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span></span><br><span class="line"><span class="comment"> * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment"> * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment"> * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个方法名yield本身就是一个“让”的意思（一键翻译就是好<img src="/2020/07/06/java-thread/0102CBE4.png" alt="img">）</p>
<p><img src="/2020/07/06/java-thread/image-20210116015403271.png" alt></p>
<p>但是，从注释里面可以看出来，它只是告诉cpu，我可以让出cpu给其他线程使用，但是至于cpu搭理不搭理，则不取决于当前线程，很有可能刚让出cpu下一个又立马获取到。跟sleep方法一定会让出cpu指定的时间，不再参与竞争有所区别。</p>
<p><strong>从线程状态转移上来说，yield方法不会使线程退出RUNNABLE状态。而sleep方法则一定会使状态变为TIMED_WAITING状态</strong>。</p>
<h5 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h5><p>join方法是将线程状态转为WAITING或者TIMED_WAITING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察源码我们发现，join方法里面其实是调用Thread父类Object的wait方法。我们上面比较的时候说过，执行wait方法拿到monitor锁，必须配合synchronized使用。在方法确实被synchronized关键字修饰，并且是一个非静态类方法，说明锁的不是class文件，而是当前对象实例的monitor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"---main----"</span>);</span><br><span class="line">    ThreadA threadA =<span class="keyword">new</span> ThreadA();</span><br><span class="line"></span><br><span class="line">    threadA.start();</span><br><span class="line">    threadA.join();</span><br><span class="line">    System.out.println(<span class="string">"---main---"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如上面例子，当时看到这里，当时有个疑问，<strong>isAlive()方法是判断main线程还是threadA线程是否存活？既然通过isAlive()方法判断线程是否存活，随后执行wait方法，按理说应该是threadA等待，但事实是main方法等待？</strong></p>
<p>第一个问题，isAlive其实是Thread类的一个普通方法，只是它是本地方法。当main线程执行threadA.join()方法时，此时this thread则是threadA，所以isAlive()方法判断的是threadA线程是否存活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if this thread is alive. A thread is alive if it has</span></span><br><span class="line"><span class="comment"> * been started and has not yet died.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread is alive;</span></span><br><span class="line"><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>第二个问题，因为是main线程执行的join方法，而join方法被synchronized关键字修饰，所以当执行进来时，main线程必然已经获取到了threadA线程的锁，此时执行wait方式，是main线程的wait方法，因此是main线程等待。那什么时候main线程会被唤醒呢，<em>As a thread terminates the {@code this.notifyAll} method is invoked.</em>这句注释说道，当threadA线程终止执行时，this.notifyAll会被调用，因此唤醒等待threadA锁的线程，即main函数会被唤醒。</p>
<p>所以，总结到，<strong>join方法实现了一定的线程同步，即当前线程只有等join方法所属的线程对象所代表的线程终止执行了才会继续往下执行，否则将一直挂起等待</strong>。但如果threadA线程一直被挂起，那么main线程一直在等待被唤醒，那么程序就有可能一直停在那里，所以源码中还提供了带有时间参数的方法。</p>
<h5 id="线程中断相关方法"><a href="#线程中断相关方法" class="headerlink" title="线程中断相关方法"></a>线程中断相关方法</h5><p><strong>如何优雅的中断一个线程？</strong></p>
<p>在早些版本有提供stop()方法，但是stop方法犹如电脑直接切掉电源，危害极大，因此已经被标为过时，这里不提。</p>
<p>在现有方案中，JDK提供了一个中断机制，使得被中断的线程有机会从当前的任务中跳出来。中断机制中最核心的两个概念是<strong>中断标志位</strong>和<strong>中断异常InterruptedException</strong>。</p>
<h6 id="中断标志位"><a href="#中断标志位" class="headerlink" title="中断标志位"></a>中断标志位</h6><p>首先来讲中断标志位，在Thread类中，并没有一个字段来作为中断标志位，而是提供了获取中断标志位的接口。这是一个私有的本地方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment"> * passed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p>而Thread类提供了两个public方法来使用该native方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isInterrupted</strong>方法调用了<strong>isInterrupted(false)</strong>方法，即只返回了线程实例的中断状态。而<strong>interrupted()</strong>则是将<strong>当前执行的线程，重置中断标志位后，并返回中断标志位</strong>。</p>
<h6 id="中断异常"><a href="#中断异常" class="headerlink" title="中断异常"></a>中断异常</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thrown when a thread is waiting, sleeping, or otherwise occupied,</span></span><br><span class="line"><span class="comment"> * and the thread is interrupted, either before or during the activity.</span></span><br><span class="line"><span class="comment"> * Occasionally a method may wish to test whether the current</span></span><br><span class="line"><span class="comment"> * thread has been interrupted, and if so, to immediately throw</span></span><br><span class="line"><span class="comment"> * this exception.  The following code can be used to achieve</span></span><br><span class="line"><span class="comment"> * this effect:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  if (Thread.interrupted())  // Clears interrupted status!</span></span><br><span class="line"><span class="comment"> *      throw new InterruptedException();</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Frank Yellin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait(long)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#wait(long, int)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#sleep(long)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Thread#interrupted()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterruptedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6700697376100628473L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with no detail  message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterruptedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an &lt;code&gt;InterruptedException&lt;/code&gt; with the</span></span><br><span class="line"><span class="comment">     * specified detail message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   s   the detail message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterruptedException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中解释道，当线程处于waiting、sleeping、甚至是正在运行的过程中，<strong>如果被中断，则抛出该异常。但也仅仅是抛出异常，并不会影响当前线程的执行</strong>。</p>
<h6 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment"> * always permitted, the &#123;<span class="doctag">@link</span> #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment"> * of this thread is invoked, which may cause a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * SecurityException&#125; to be thrown.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Object#wait() wait()&#125;, &#123;<span class="doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment"> * class, or of the &#123;<span class="doctag">@link</span> #join()&#125;, &#123;<span class="doctag">@link</span> #join(long)&#125;, &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #join(long, int)&#125;, &#123;<span class="doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="doctag">@link</span> #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment"> * methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment"> * will receive an &#123;<span class="doctag">@link</span> InterruptedException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment"> * then the channel will be closed, the thread's interrupt</span></span><br><span class="line"><span class="comment"> * status will be set, and the thread will receive a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If this thread is blocked in a &#123;<span class="doctag">@link</span> java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment"> * then the thread's interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment"> * immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment"> * value, just as if the selector's &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; If none of the previous conditions hold then this thread's interrupt</span></span><br><span class="line"><span class="comment"> * status will be set. &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment"> *          if the current thread cannot modify this thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@spec</span> JSR-51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法注释解释下来作用是中断线程，并且如果线程因为以下方法而处于阻塞中：</p>
<ul>
<li>Object的方法<ul>
<li>wait()</li>
<li>wait(long)</li>
<li>wait(long, int)</li>
</ul>
</li>
<li>Thread的方法<ul>
<li>join()</li>
<li>join(long)</li>
<li>join(long, int)</li>
<li>sleep(long)</li>
<li>sleep(long, int)</li>
</ul>
</li>
</ul>
<p>那么，在调用interru()方法后，线程的中断标志会被清除，并且收到一个InterruptedException异常。</p>
<p>所以在AQS分析中也有这个方法的作用解释，因为这个方法抛出异常并同时清除中断标志位，但是此时还不想或者无法传递该异常，不对该异常做任何处理，因此要再次调用interrupt来恢复中断的状态，供上层调用者使用。</p>
<h6 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h6><p>所以经过上面几个知识点的学习，问题的最后，那么到底怎么终止处理阻塞状态的线程呢？</p>
<p>如果一个线程在<strong>阻塞状态</strong>(有可能调用sleep、wait、join方法)，如果中断这个线程，那么这些方法将会抛出InterruptedException异常，那么我们就可以通过这个异常来使线程跳出阻塞状态，从而终止线程。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// do some task</span></span><br><span class="line">            <span class="comment">// blocked by calling wait/sleep/join</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            <span class="comment">// 如果该线程被中断，则会抛出InterruptedException异常</span></span><br><span class="line">            <span class="comment">// 我们通过捕获这个异常，使得线程从block状态退出</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break, 可以使我们在线程中断后退出死循环，从而终止线程。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个线程处于<strong>运行状态</strong>，那么中断这个线程只会将该线程的中断标志位设为ture，并不会抛出InterruptedException异常。那么为了能够在运行过程中感知线程已经被中断，那么只能通过循环不断查询这个状态来实现终止线程。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// do some task...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以结合上面两种，到这里可以解决<strong>如何优雅的中断一个线程？</strong>可以通过以下方式，终止任意一个存活的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. isInterrupted() 用于终止一个正在运行的线程。</span></span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        <span class="comment">// 2. InterruptedException异常用于终止一个处于阻塞状态的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时要注意，捕获这个InterruptedException异常，要在while循环外面，如果是以下这种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//isInterrupted() 用于终止一个正在运行的线程。</span></span><br><span class="line">    <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            <span class="comment">// 在这里不做任何处理，仅仅依靠isInterrupted检测异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即其他线程调用该线程的interrupt()方法，会抛出异常且会重置中断标识位，因此isInterrupted()方法会返回false。所以导致跳不出循环。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>中断机制的核心在于中断状态和<code>InterruptedException</code>异常。</p>
<p>中断状态:</p>
<ul>
<li>设置一个中断状态: Thread#interrupt</li>
<li>清除一个中断状态: Thread.interrupted，并且返回线程原来的中断状态。例如在这个demo中，当i==100时，调用Thread.interrupted方法，<strong>重置了中断标志位，且返回重置之前的状态</strong>。</li>
</ul>
<p><img src="/2020/07/06/java-thread/image-20210116142811213.png" alt></p>
<p>我们可以使用Thread#interrupt中断一个线程，被中断的线程所受的影响为以下两种之一:</p>
<ul>
<li>若被中断前，该线程处于非阻塞状态，那么该线程的中断状态被设为true, 除此之外，不会发生任何事。</li>
<li>若被中断前，该线程处于阻塞状态(调用了wait,sleep,join等方法)，那么该线程将会立即从阻塞状态中退出，并抛出一个InterruptedException异常，同时，该线程的中断状态被设为false, 除此之外，不会发生任何事。</li>
</ul>
<p>但是，<strong>不管是中断状态的改变还是还是<code>InterruptedException</code>被抛出，如果程序做任何处理，那么中断机制对当前线程没有任何影响</strong>。</p>
<p>因此，要记住，中断一个线程，只是传递了中断的消息，并不会真正的阻止一个线程的运行。</p>
<h4 id="ThreadLocal相关"><a href="#ThreadLocal相关" class="headerlink" title="ThreadLocal相关"></a>ThreadLocal相关</h4><p><a href="https://blog.yzylcc.top/2020/04/29/java-threadLocal/" target="_blank" rel="noopener">Java基础之ThreadLocal(一)</a></p>
<blockquote>
<p>参考资料</p>
<ol>
<li><a href="https://www.zhihu.com/question/56494969" target="_blank" rel="noopener">https://www.zhihu.com/question/56494969</a></li>
<li><a href="https://segmentfault.com/a/1190000016029782" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016029782</a></li>
<li><a href="https://segmentfault.com/a/1190000016083002（写的很好）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016083002（写的很好）</a></li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/27/java-LongAdder/" rel="prev" title="Java基础之LongAdder">
      <i class="fa fa-chevron-left"></i> Java基础之LongAdder
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/18/java-FutureTask/" rel="next" title="Java基础之FutureTask">
      Java基础之FutureTask <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread生命周期"><span class="nav-number">1.</span> <span class="nav-text">Thread生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread类"><span class="nav-number">2.</span> <span class="nav-text">Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable接口"><span class="nav-number">2.1.</span> <span class="nav-text">Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的创建"><span class="nav-number">2.2.</span> <span class="nav-text">线程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的方法"><span class="nav-number">2.3.</span> <span class="nav-text">线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#currentThread方法"><span class="nav-number">2.3.1.</span> <span class="nav-text">currentThread方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep-long-方法"><span class="nav-number">2.3.2.</span> <span class="nav-text">sleep(long)方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#yield-方法"><span class="nav-number">2.3.3.</span> <span class="nav-text">yield()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#join方法"><span class="nav-number">2.3.4.</span> <span class="nav-text">join方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程中断相关方法"><span class="nav-number">2.3.5.</span> <span class="nav-text">线程中断相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#中断标志位"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">中断标志位</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#中断异常"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">中断异常</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#interrupt"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">interrupt()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#终止线程"><span class="nav-number">2.3.5.4.</span> <span class="nav-text">终止线程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">2.3.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal相关"><span class="nav-number">2.4.</span> <span class="nav-text">ThreadLocal相关</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lcc</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备18032544号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lcc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">416k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:19</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.7/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'LvCFelhSs5qo2YxIqHl88ejb-gzGzoHsz',
      appKey     : 'ryaWfNw4bBIuGCIHeUbN2Gb2',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
