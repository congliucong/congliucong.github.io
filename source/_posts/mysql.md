---
title: Mysql之事务篇
date: 2020-04-19 13:52:55
tags: Mysql
categories: Mysql
---

这篇文章主要对Mysql的事务相关知识，进行梳理。

目前的思路是通过文章的方式，将各个知识点梳理成体系，以后查漏补缺，复习总结。越来越发现，写文章是一种很好的方式去督促自己不断学习。只有不断学习，提高自己硬实力，这样才能够在日后做到手有余量，心里不慌。

<!-- more -->

### 事务的特性ACID

* 原子性

原子性通俗来讲，就是 一个事务中的操作，要么全部提交成功，要么全部失败回滚。不允许只执行其中的一部分。对于Mysql来讲，实现原子性是通过**undo log**来实现的。发生回滚的时候根据undo log来进行相反的操作。

* 一致性

数据库总是从一个一致性的状态转移到另外一个一致性的状态。

* 隔离性

隔离性指的是一个事务所做的修改在最终提交之前，对其他事务不可见。通俗点讲，就是在我事务没有提交之前，你所看到的数据跟我开始事务之前的数据状态一致。对于Mysql来说，通过锁机制来保证一个写操作对另外一个写操作的隔离。通过MVCC来保证一个写操作对读操作的隔离。

* 持久性

持久性指的是一旦事务提交，其所做的修改就会永久保存在数据库中。对于Mysql来说，实现持久性是通过**redo log**来实现的，所有修改先写到日志，再更新到缓存，保证数据不会因为宕机而丢失。

### 隔离级别

隔离级别是对事务隔离性的实现，一般来说有四种隔离界别

* READ UNCOMMITTED(未提交读)

指的是事务中的修改，即使没有提交，对其他事务来说，也是可见的。事务可以读取到未提交的数据，这种情况叫做“脏读”。这种隔离级别有很多问题，一般来说很少使用。

* READ COMMITTED(提交读)

指的是 一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说就是事务开始直到提交之前，所做的操作对其他事务都不可见。也叫做不可重复读，因为两次执行同样的查询，结果不一样。

* REPEATABLE READ(可重复读)

脏读是说的是能够读到未提交的事务，而可重复读则解决了脏读的问题。这个隔离级别保证了一个事务中 多次读取同样的记录结果是一致的。但是可重复读不能解决幻读的问题，幻读指的是 当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，发现多了一行，产生幻行。

* SERIALIZABLE（可串行化）

可串行化是最高的隔离级别，强制事务串行执行。一般也很少使用。

### Mysql到底是如何解决幻读的？

这个问题在《高性能Mysql》中说：

> InnoDB通过多版本并发控制（MVCC）解决幻读的问题。

也有说是通过 ***Next-Key-locks*** 解决幻读问题。查阅相关资料后，可以看出来两种说法都是正确的，只是针对的角度不一样。下面先说明什么是MVCC 和 Next-Key-locks。

#### MVCC

MVCC是 多版本并发控制的简称。在InnoDB中，是通过在每行记录后面保存两个隐藏列来实现的MVCC。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（删除时间）。当然，实际存储的是系统版本号。每开启一个新的事物，系统版本号都会自动递增。

* SELECT

查询时，读取创建版本号<=当前事务版本号 && 删除版本号为空或 >当前事务版本号

* INSERT

保存当前事务版本号为行的创建版本号

* DELETE

保存当前事务版本号为行的删除版本号

* UPDATE

插入一条新记录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来行作为行删除版本号。

#### Next-Key锁

Next-Key锁是行锁和GAP（间隙锁）的合并。

##### 行锁

当表中某条数据进行写操作（insert update delete select for update），需要先获取记录的排它锁，这个称之为行锁。行锁是针对索引加锁的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表锁。

##### GAP锁

锁定索引记录间隙，确保索引记录的间隙不变。只作用在可重复读的隔离级别下。间隙的范围是向上寻找最靠近检索条件的记录A作为左区间，向下寻找最靠近检索条件的记录B作为右区间，即为锁定的间隙。GAP锁只作用于 非唯一索引（锁区间） 或者 没有索引（给全表加入gap锁）。

#### 那到底如何解决幻读问题？

根据 读 的类型，可以分为两种读。对于读取历史数据 的方式，称之为 **快照读**。对于读取数据库当前版本数据的方式，叫做 **当前读**。

在MVCC中，

快照读：就是 select。

* select * from table.....

当前读：插入/更新/删除操作，处理的是当前的数据

- select * from table where ? lock in share mode;
- select * from table where ? for update;
- insert
- update 
- delete

对于快照读，因为有MVCC的存在，保证了读取创建版本号<=当前版本号 且 删除版本号为空或者小于当前版本号的数据，所以MVCC机制解决了RR(可重复读)级别下 **读操作**的幻读问题 。

而与当前读来说，解决幻读问题是 Next-Key锁。行锁来锁当前记录，防止别的事务修改或删除，GAP锁锁区间，防止别的事务新增。因此行锁+GAP锁组成的Next-key锁共同解决了RR（可重复读）级别下**Next-Key锁**时的幻读问题。

#### 总结

所以，从上面看来，InnoDB解决幻读是通过MVCC 和 Next-Key锁解决幻读，这两种说法都正确。

### redo log

上面介绍事务的特性时提到，Mysql 通过undo log来实现事务的持久性。redo log记录事务执行后的状态。主要作用于数据库的崩溃恢复。

#### redo的工作流程：

* 先将原始数据从磁盘中读到内存里，修改数据的内存拷贝
* 生成一条重做日志并写入到redo log buffer，记录的是数据被修改后的值
* 当事务commit时，将redo log buffer的内容刷新到磁盘的redo log file,对redo log file采用追加写的方式
* 定期将内存汇总修改的数据刷新到磁盘中。



#### redo如何保证事务的持久性：

InnoDB通过 Force log at commit机制保证事务的持久性，即在事务提交之前，先将redo log buffer写入到磁盘redo log file进行持久化，内存中被修改的数据在后台可以慢慢的刷回到磁盘中。称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。先日志，后磁盘。如果此时有select操作，而数据还没刷回到磁盘，此时直接读内存。

### undo log

undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要记录全部的操作。undo log主要有两个作用：回滚 和 多版本控制。回滚的时候，实际上做着相反的工作，比如一条insert，对应一条delete，对于每一个update，对应着一个相反的update。正是由于undo log，保证了事务的原子性。

> ​	参考内容：
>
> 1. https://tech.meituan.com/2014/08/20/innodb-lock.html
> 2. https://zhuanlan.zhihu.com/p/112106862
> 3. 《高性能Mysql》第三版