---
title: Java基础之HashMap
date: 2020-04-23 22:28:53
tags: Java
categories: Java基础
---

博客里面没有一篇HashMap的总结，不能叫做技术博客。且不说HashMap也是面试中的重头戏，每个Java Coder都需要掌握的吧。先不说红黑树这么左旋右旋删除添加这种有难度的操作，其他问题总归该掌握的。比如JDK 1.7 1.8 中红黑树区别？HashMap的数组长度为何要是2的整数次幂？如何解决Hash冲突的？HashMap又是如何扩容的？JDK1.8比JDK1.7中优化点在哪？HashMap是线程不安全的，体现在哪里？甚至还可以引申出ConcurrentHashMap，然后又是一大堆问题。哈哈哈哈，光随便想想，就头皮发麻。

时刻记住，稳住，不要慌。现在来一一击破。![](HashMap/00CC4258.png)

<!-- more -->

### HashMap

![](HashMap/HashMap-structure.png)

JDK1.7中，HashMap底层数据结构为 **数组 + 链表**。JDK1.8中，HashMap底层数据结构为 **数组 + 链表 + 红黑树**。（第一个区别点就出来了）

HashMap默认**初始值**为 16 ，最大为2的30次方。当没有指定默认值时，new HashMap()，并不会初始化数组，而是等到第一次put时，会调用resize()进行初始化。

HashMap默认**加载因子**为0.75，扩容阈值为 数组长度 * 加载因子。

HashMap当链表**长度达到8时且容量达到64**时，进行**树化**。当链表**长度小于6时进行反树化**。这里可能会有人问为什么反树化是6？假设当树化、反树化都是8的话，如果在hashmap中频繁插入删除，那么hashmap就有可能频繁进行树化反树化。让这两个值有一定的差值，可以防止树和链表频繁转换。

### put过程

1. 计算key的hash值

这里JDK1.7和JDK1.8稍有不同。**扰动函数**：JDK1.7是进行四次右位移异或，而JDK1.8简化为只做一次16位右位移异或混合。右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，这样可以混合原始哈希码的高位和低位。以此加大低位的随机性，而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

2. 如果数组数量为0，则初始化数组。

3. 将hash值与数组长度-1 (n - 1) & hash 进行 “与”操作计算出元素所在数组位置。

这里可以体现出为什么 HashMap的数组长度要取2的整次幂？因为数组长度-1 正好相当于一个**低位掩码**，hash值是一个int型，直接拿hash值所谓数组下标的话，int型的值范围从-21亿到+21亿，前后加起来大约40亿的映射空间，内存是放不下的，因此与操作的结果将hash值高位全部归零，只保留低位值，用做数组下标访问。例如初始长度16,16-1=15，相当于00001111，因此hash值 & 00001111，相当于只截取最低四位位。再加上扰动函数，使得碰撞次数大大降低。