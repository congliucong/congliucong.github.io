---
title: Redis知识归纳(七)缓存与数据库双写一致性
date: 2020-04-06 19:59:33
tags: Redis
categories: Redis
---

只要用到缓存，就肯定会涉及到缓存与数据库双写，只要发生双写，就一定会有一致性问题。

<!-- more -->

但是对于这个问题，我们首先要肯定两点：

1. 缓存必须要有过期时间

对于缓存来说，必须设有过期时间的意义在于当缓存命中率低的时候，如果不设置过期时间，那么会一直占据内存空间，要知道内存空间也是一种资源。当命中率高的时候，我们可以在每次命中的时候刷新过期时间，保证热点缓存一直都在，这样就可以保证缓存的命中率和系统的性能。

2. 保证数据库跟缓存的最终一致性即可，不必追求强一致性。

如果要保证强一致性，势必要引入分布式一致性协议或者是分布式锁，那么系统的复杂度就可能随之而提高，而且既然追求强一致性，那么缓存的意义也就不复存在。

### Cache Aside Pattern

对于缓存数据库一致性问题，Cache Aside Pattern是最经典的方案。它要求：

1. 读的时候先读缓存，如果缓存没有的话，就读数据库，读出数据后将数据放入缓存中，然后返回响应。
2. 更新的时候，**先更新数据库，再删除缓存**。

首先，从数据持久化的角度来说，数据库当然要比缓存做得好，并且我们也应该以数据库中的数据为主。所以我们更新数据的时候，要先更新数据库，再操作缓存。

**但为什么是删除缓存而不是更新缓存？**

因为很多情况，在复杂点的缓存场景中，缓存不单单是数据库中直接取出来的值，而是通过计算的出来的值。比如可能更新了某表的一个字段，然后其对应的缓存是需要查询另外两个表的数据并才能计算出来缓存的值。所以**如果频繁更新表中数据导致频繁更新缓存，从而产生大量的无效计算，造成机器性能浪费，所以更新缓存的代价是很高的**。并且我们并**不能确定更新的这个缓存是不是会被经常读取**，如果没有被经常读取，那么更新缓存所浪费的时间是没有意义的，既然这样，我们就可以考虑**用到缓存的时候再去计算**，其实也就是一种懒加载的思想。

但这种方案也会存在问题，假如更新数据库成功，但是删除缓存失败，从而导致缓存中的数据是旧数据，从而导致读取到的数据一直是旧数据。

**我们可以引入消息队列，在删除缓存失败的情况下，由消息队列消费者保证删除缓存以及重试。**