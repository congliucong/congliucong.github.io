---
title: MySQL之索引原理及慢查询优化
date: 2020-04-19 23:42:21
tags: Mysql
categories: Mysql
---

这篇文章主要接上篇文章，对Mysql的索引相关知识进行梳理。

<!-- more -->

### 索引

索引是存储引擎用于快速找到记录的一种数据结构。

### 为什么索引要使用B+Tree?

#### Hash索引

hash表示通过关键字段的哈希值通过哈希函数的转换映射到哈希表对应的位置上，因此查询效率非常高。哈希索引基于hash表实现的。但是hash索引存在着以下问题：

1. 只有精确匹配所有列的查询才有效，比如组合索引（A,B）上建立了哈希索引，如果只查询A，那么是无法使用该索引。
2. 哈希索引不是根据索引值顺序存储的，所以无法使用排序。
3. 哈希索引只能支持等值比较，不支持任何范围查找。
4. 如果大量重复键值的情况下，会存在大量哈希碰撞，哈希索引的效率会很低，

所以hash索引，只是用于特殊的场合。例如InnoDB引擎中的“自适应哈希索引”：如果InnoDB注意到某些索引列被频繁访问，它会在内存基于B+树索引之上再创建一个哈希索引 ，这样就能让B+树也具有哈希索引的优点。

#### B-Tree索引/B+Tree索引

B-Tree是一种多路平衡查询数。B+Tree是B-Tree的优化版本。

那么B-Tree和B+Tree树有什么区别呢？

1. B-Tree每个节点即保存索引，又保存数据。B+Tree的关键字非叶子节点存储的是索引，而非数据，只有叶子节点存放诗句。
2. B+Tree的叶子节点之间构成链表，遍历叶子节点就能获取全部数据。

因此，B+树可以使得树高更矮，从而降低磁盘IO次数，提高查询速度。所以在InnoDB引擎中，索引的数据结构默认是B+树。

#### 局部性原理与磁盘预读

局部性原理和磁盘预读我们在volatile分析时 缓存行那里介绍 过。大概意思是：当一个数据被用到时，其附近的数据也通常会被马上使用到，所以一般会预读长度为一页的整数倍。页是计算机存储的逻辑块，硬件和操作系统通常将主存和磁盘存储块分割为连续大小相等的块，每个存储块称为一页，主存和磁盘以页为单位交换数据。

#### B+Tree索引性能分析

所以有了局部性原理和磁盘预读，mysql利用这个原理，**将一个节点的大小设置为一页，这样每个节点只需要一次IO就可以完全载入**。因为B+树非叶子节点存储的是索引，而非数据，因此每个节点可以存储更多的索引，这样就能整体降低B+树的高度，从而减少磁盘IO次数。这也就是为什么我们要求索引字段尽量小，都是为了在每一个节点尽量存储更多的数据，而降低树高。

### Mysql索引实现