---
title: 深入JVM之JVM调优
date: 2020-05-01 22:29:42
tags: Java JVM
categories: Jvm相关
---

上篇我们分析了常见的垃圾回收器，我们这篇聚焦于内存分配与系统问题定位实践。这部分知识才是体现一个Java工程师的实力，毕竟纯理论知识要落地才有价值。

起飞吧少年~![](jvm3/02B8D45D.png)

<!-- more -->

## 内存分配与回收策略

1. **对象优先在Eden区分配**

对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

2. **大对象直接进入老年代**

大量需要内存空间的Java对象，但是Eden区无法存放，因此大于设置的值的对象直接在老年代分配。

3. **长期存活的对象进入老年代**

对象在Survior区每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度后（默认15），就会被晋升到老年代。可以通过 -XX: MaxTenuringThreadhold设置。

4. **动态对象年龄判定**

HotSpot虚拟机并不是永远要求对象的年龄达到 -XX: MaxTenuringThreshold 才能晋升老年代，如果在survivor空间中相同年龄所有对象大小的总和大于Survior空间的一半，年龄大于或者等于该年龄的对象就会直接进入老年代。

5. **空间分配担保**

在发生Minor GC之前，会判断老年代最大可用的连续空间是否大于新生代所有对象空间或者大于历次晋升的平均大小，如果大于，则可以把存活的对象移入到老年代，否则，则要触发full gc。

## GC概念

### 各种GC含义

**Minor GC/Young GC**:

针对新生代的垃圾回收称之为Minor GC/ Young GC。

**Major GC/Old GC**:

针对老年代的垃圾收集。只有CMS会单独收集老年代的行为，其他能收集老年代的GC都会同时收集整个GC堆。

**Full GC:**

收集整个Java堆和方法区的垃圾收集

**Mixed GC:**

收集整个新生代以及部分老年代的垃圾收集。只有G1收集器会有这种行为。

### 什么时候触发GC?

**Young GC:** 当新生代的Eden区分配满的时候会触发Young GC。

**Full GC:** 

1. 当触发Young GC时，发现**历次晋升到老年代对象的平均大小**大于**老年代最大可用连续空间**或者**新生代对象大小**大于**老年代最大可用连续空间**，则不会触发Young GC转而触发Full GC。
2. Perm Gen空间不足以分配 ，也会触发full gc。
3. System.gc()默认也是触发 full gc。

**Mixed GC**:一旦老年代占据堆内存45%，触发Mixed GC。

## 常见工具

### jstat

如果要查看JVM的整体运行情况 ，可以用jstat。可以轻易的看出当前运行中的系统JVM的Eden/Survivor/老年代的内存使用情况，还有Young GC和Full GC的执行次数以及耗时。

![](jvm3/image-20200502103800059.png)

**jstat -gc PID**

1. S0C : From Survivor区的大小
2. S0C : To Survivor区的大小
3. S0U :  From Survivor区的使用内存大小
4. S1U : To Survivor区的使用内存代销
5. EC : Eden 区的大小
6. EU : Eden 区当前使用内存的大小
7. OC : 老年代的大小
8. OU : 老年代当前使用内存的大小
9. MC : 方法区的大小
10. MU : 方法区当前使用内存大小
11. YGC : 系统运行迄今为止Young GC次数
12. YGCT : 系统运行迄今为止Young GC耗时
13. FGC : 系统运行迄今为止Full GC次数
14. FGCT : 系统运行迄今为止Full GC耗时
15. GCT : 所有GC的总耗时

#### **应该如何使用jstat工具？**

只要合理分配内存空间，尽可能的让对象留在年轻代不进入老年代，避免频繁发生full gc，就是JVM最好的性能优化。

1. 首先要知道 **新生代对象增长的速率**，即随着系统运行，每秒钟会在年轻代的Eden区分配多少对象。

只需要运行 **jstat -gc PID 1000 10**，意思是每个 一秒钟更新出来一行jstat统计信息，一共执行10次统计。通过这个命令，就可以灵活的对线上机器通过固定频率输出统计信息，观察Eden区对象占用变化。如果系统负载不高，那么可以将时间设置为1分钟、10分钟等，同时在高峰时间段和非高峰时间段查看对象增长速率，这样首先对系统有个清晰的认识。

2. **Young GC的触发频率和每次耗时**

在上一步的对象增长速率能够大概清楚了，那么Young gc就也可以推断出来，比如Eden区1G，每秒新增5MB，那么大概会三四分钟触发一次Young gc。经过多次Young gc后，总耗时/总次数即可大概算出每次耗时，大概就能知道每次Young GC的时候会导致系统停顿多长时间。

3. **每次Young GC后有多少对象是存活和进入老年代**

既然推断出大概3分钟一次Young GC，那么可以执行 jstat -gc PID 180000 10，相当于每隔3分钟执行一次统计，连续执行10次，可以观察每3分钟后Eden  Survivor 老年代的对象变化。比如每次Young GC后老年代新增50MB，那么老年代的增长速率也就可以知道了。

4. **Full GC的触发时机和耗时**

知道了老年代对象的增长速率，那么Full GC的触发时机也就可以知道了。

因此，通过jstat可以知道系统JVM的运行情况，就可以针对性的进行优化。

### jmap/jhat

通过jstat知道了系统的jvm情况，就可以通过jmap 和jhat 观察系统JVM中对象分布，了解大系统平时运行过程中，到底哪些对象占据了主角位置，占据了多少内存空间，对系统可以有更加细致的了解。

#### jmap

当发现JVM新增对象的速度很快时，就可以用jmap去了解系统的对象分布。

**1. jmap -heap PID**可以了解系统运行时的内存区域，不过还是jstat信息全点，一般不用这个。

![](jvm3/image-20200502103828431.png)

**2. jmap -histo PID 了解系统运行时的对象**

![](jvm3/image-20200502105245676.png)

**3. jmap -dump:live,format=b,file=dump.hprof PID，使用jmap生成堆内存转储快照**

该命令会在当前目录下生成一个dump.hrpof文件，这个文件是二进制格式，不能直接看。因此我们可以用jhat。

![](jvm3/image-20200502105629585.png)

#### jhat

我们可以用jhat在浏览器中分析堆转出快照，jhat内置了web服务器，可以通过浏览器来图形化分析堆转储快照。

**jhat  -port 7000 dump.hprof**

![](jvm3/image-20200502110345084.png)

## JVM合理设置步骤

1. **系统开发好后的预估性优化**

系统开发完毕，先对系统进行预估性的优化，即估算系统每秒大概多少请求，每个请求会创建多少对象啊，占用多少内存，机器应该选用什么样的配置、年轻代应该给多少内存、Young GC触发的频率、对象进入老年代的速度、老年代应该给多少内存、Full GC触发的频率等。

优化的思路是：尽量让每次Young GC后存活的对象小于Survivor区域的50%，都留存在年轻代。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。

2. **系统压测时的JVM优化**

预估性优化之后，还要经过一连串的测试，在一定压力下性能、稳定性、和并发能力都正常，会可以部署到生产环境中。

这里有个非常关键的环节就是预发布环境的压力测试。 比如使用压力测试工具模拟1000个用户同时访问系统，造成每秒500个请求的压力，看系统能否支撑每秒500请求的压力，同时看系统各个接口的相应延时能够在200ms之内，也就是接口的性能不能太慢，或者在数据库中模拟出来百万级单表数据，看系统是否能稳定运行。

所以就可以在压测的环节，对测试机器运行的系统，采用jstat工具来分析模拟真实环境下的压力。

根据压测环境中的jvm运行情况，如果发现对象过快进入老年代，那么可能是年轻代太小导致频繁的Young GC，然后Young GC的时候很多对象还是存活的，结果Survivor也太小，导致很多对象频繁进入老年代。

总之就是合理调整新生代、老年代、Eden、Survivor各个区域的内存大小，保证对象尽量留在新生代，不要过快进入老年代。

3. **对线上系统进行JVM监控**

1. 第一种方式比较LOW，就是每天在高峰期、低峰期都用jstat/jmap/jhat工具查看线上系统JVM运行情况，有没有频繁full gc的问题。
2. 部署专门的监控系统，Zabbix/OpenFalcon/Ganglia等。

## JVM优化实际案例